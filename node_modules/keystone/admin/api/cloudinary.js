var keystone = require('../../');
var fs = require('fs');
var http = require('http');
var crypto = require('crypto');

exports = module.exports = {

	upload: function(req, res) {
		if(req.files && req.files.file && (req.body.remote == "")){
			var options = {};
			if (keystone.get('wysiwyg cloudinary images filenameAsPublicID')) {
				options.public_id = req.files.file.originalname.substring(0, req.files.file.originalname.lastIndexOf('.'));
			}
			fs.rename(req.files.file.path, 'public/uploads/'+req.files.file.name);
			var loc = "http://localhost:3000/uploads/"+req.files.file.name;
			res.set('Content-Type', 'text/html');
			res.json({image: {url: loc}});
			
		} else {
			if (req.body.remote != "") { 
				// TODO: what if it's not jpg but png, gif etc.
				var splitup = req.body.remote.split('/');
				var filename = splitup[splitup.length - 1];
				var extension = '';
				if (filename.endsWith('jpg') || filename.endsWith('JPG'))
					extension = '.jpg';
				else
					if (filename.endsWith('png') || filename.endsWith('PNG'))
						extension = '.png';
					else
						if (filename.endsWith('gif') || filename.endsWith('GIF'))
							extension = '.gif';
				if (splitup[0].substr(0,4) != 'http' && splitup[1] != '')
				{
					res.json({ error: { message: 'Please enter full link, including http://' }});
				}
				var hos = splitup[2];
				var pat = '';
				for (i=3; i<splitup.length; i++)
				{
					pat += splitup[i];
					pat += '/';
				}
				pat = '/'+pat.substr(0,pat.length-1);
				var options;
				options = {
    				host: hos,
  				port: 80,
  				path: pat
				};
				var request = http.get(options, function(resp)
				{
					var imagedata = '';
					resp.setEncoding('binary');
					resp.on('data', function(chunk){
		        		imagedata += chunk;
	    				});
    					resp.on('end', function(){ 
						var loc = '';
        					fs.writeFile('public/uploads/'+options.host+options.path.replace(/\//g,'_'), imagedata, 'binary', function(err){
		        	    			if (err) throw err; });
						var md5 = crypto.createHash('md5').update('public/uploads/'+options.host+options.path.replace(/\//g,'_')).digest("hex");
						md5 = crypto.createHash('md5').update(md5).digest("hex");
						fs.rename('public/uploads/'+options.host+options.path.replace(/\//g,'_'), 'public/uploads/'+md5+extension);
						loc = "http://localhost:3000/uploads/"+md5+extension;
						res.set('Content-Type', 'text/html');
						res.json({image: {url: loc}});
				});


		});
				
			}
			else { 
				res.json({ error: { message: 'No image selected' } });
			}
		}
	},

	autocomplete: function(req, res) {
		/*var max = req.query.max || 10;
		var prefix = req.query.prefix || '';
		var next = req.query.next || null;

		cloudinary.api.resources(function(result) {
			if (result.error) {
				res.json({ error: { message: result.error.message } });
			} else {
				res.json({
					next: result.next_cursor,
					items: result.resources
				});
			}
		}, { 
			type: 'upload',
			prefix: prefix,
			max_results: max,
			next_cursor: next
		});*/
	},

	get: function(req, res) {
		/*cloudinary.api.resource(req.query.id, function(result) {
			if (result.error) {
				res.json({ error: { message: result.error.message } });
			} else {
				res.json({ item: result });	
			}
		});*/
	}
};
